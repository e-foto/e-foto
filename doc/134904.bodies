class IOManager
!!!140152.cpp!!!	IOManager()
	manager = NULL;
	mySensor = NULL;
	myImage = NULL;
	myIO = NULL;
	started = false;
	status = false;
!!!140280.cpp!!!	IOManager(inout manager : EFotoManager, inout mySensor : Sensor, inout myImage : Image, inout myIO : InteriorOrientation)
	this->manager = manager;
	this->mySensor = mySensor;
	this->myImage = myImage;
	this->myIO = myIO;
	started = false;
	status = false;
!!!140408.cpp!!!	~IOManager()

!!!140536.cpp!!!	setInterface(inout newInterface : IOUserInterface) : void
	myInterface = newInterface;
!!!140664.cpp!!!	getInterface() : IOUserInterface
	return myInterface;
!!!140792.cpp!!!	getAnalogMarks() : PositionMatrix
	if (mySensor != NULL)
	{
		if (mySensor->is("SensorWithFiducialMarks"))
		{
			SensorWithFiducialMarks* mySensorWithFiducialMarks = (SensorWithFiducialMarks*) mySensor;
			return PositionMatrix(mySensorWithFiducialMarks->getLb());
		}
		if (mySensor->is("SensorWithKnowDimensions"))
		{
			SensorWithKnowDimensions* mySensorWithKnowDimensions = (SensorWithKnowDimensions*) mySensor;
			return PositionMatrix(mySensorWithKnowDimensions->forgeLb());
		}
	}
	return PositionMatrix();
!!!140920.cpp!!!	measureMark(in id : int, in col : int, in lin : int) : bool
	if (started)
	{
		DigitalFiductialMark* myMark = new DigitalFiductialMark(id, myImage->getId(), col, lin);
		myImage->deleteDigFidMark(id);
		myImage->putDigFidMark(*myMark);
		return true;
	}
	return false;
!!!141048.cpp!!!	countMarks() : uint
	return myImage->countDigFidMarks();
!!!141176.cpp!!!	markData(in index : int) : deque<string>
	deque<string> result;
	if (started)
	{
		PositionMatrix analogMarks = getAnalogMarks();

                result.push_back(Conversion::doubleToString(analogMarks.get(2 * index + 1),3));
                result.push_back(Conversion::doubleToString(analogMarks.get(2 * index + 2),3));
		DigitalFiductialMark myMark = myImage->getDigFidMark(index + 1);
		if (myMark.isAvailable())
		{
                        result.push_back(Conversion::intToString(myMark.getCol()));
                        result.push_back(Conversion::intToString(myMark.getLin()));
		}
	}
	return result;
!!!141304.cpp!!!	getTotalMarks() : uint
	return getAnalogMarks().getRows() / 2;
!!!141432.cpp!!!	getCalculationMode() : int
	string mode = mySensor->getCalculationMode();
	cout << mode << endl;
	return mode == "With Fiducial Marks"? 1 : mode == "With Sensor Dimensions" ? 2 : mode == "Fixed Parameters" ? 3 : 0;
!!!141560.cpp!!!	calculateIO() : bool
	if (started)
	{
		if (mySensor->is("SensorWithFiducialMarks"))
		{
			SensorWithFiducialMarks* mySensorWithFiducialMarks = (SensorWithFiducialMarks*) mySensor;
			if ((unsigned int) myImage->countDigFidMarks() == (unsigned int) mySensorWithFiducialMarks->getLb().getRows() / 2) // Comparação entre o número de marcas digitais e analógicas. "mySensorWithFiducialMarks->getLb()->getCols() / 2" dá o número de marcas analógicas validadas, tendo Lb sido carregado direto ou através das marcas.
			{
				myIO->calculate();
				status = true;
			}
		}
		else if (mySensor->is("SensorWithKnowDimensions"))
		{
			//SensorWithKnowDimensions* mySensorWithKnowDimensions = (SensorWithKnowDimensions*) mySensor;
			myIO->calculate();
			status = true;
		}
		else if (mySensor->is("SensorWithKnowParameters"))
		{
			//SensorWithKnowParameters* mySensorWithKnowParameters = (SensorWithKnowParameters*) mySensor;
			myIO->calculate();
			status = true;
		}
	}
	return status;
!!!141688.cpp!!!	interiorDone() : bool
	if (myIO->getXa().getRows() != 6)
		return false;
	return true;
!!!141816.cpp!!!	makeReport() : deque<string>
	deque<string> result;
	result.push_back(myIO->getXa().xmlGetData());
	result.push_back(myIO->getLa().xmlGetData());
        result.push_back(Conversion::doubleToString(myIO->getQuality().getsigma0Squared()));
	result.push_back(myIO->getQuality().getV().xmlGetData());
	result.push_back(myIO->getQuality().getSigmaXa().xmlGetData());
	result.push_back(myIO->getQuality().getSigmaLa().xmlGetData());
	return result;
!!!141944.cpp!!!	exec() : bool
	if (manager != NULL && mySensor != NULL && myImage != NULL && myIO != NULL)
		if (myImage->getSensorId() == mySensor->getId() && myIO->getImageId() == myImage->getId())
		{
		if (manager->getInterfaceType().compare("Qt") == 0)
		{
			//myInterface = new IOUserInterface_Qt(this);
			myInterface = IOUserInterface_Qt::instance(this);
		}
		myImage->setSensor(mySensor);
		myIO->setImage(myImage);
		started = true;
		if (myInterface != NULL)
		{
			myInterface->exec();
		}
		//if (manager->getInterfaceType().compare("Qt") == 0)
		//{
			//IOUserInterface_Qt::createInstance(this)->exec();
		//}
	}
	return status;
!!!142072.cpp!!!	getId() : int
	if (myImage != NULL)
	{
		return myImage->getId();
	}
	return 0;
!!!142200.cpp!!!	returnProject() : void
	manager->reloadProject();
!!!142328.cpp!!!	save(in path : string) : bool
	if (started)
	{
		FILE* pFile;
                string output = "IO state data for Image " + Conversion::intToString(myImage->getId()) + "\n\n";

		output += mySensor->xmlGetData();
		output += "\n";
		output += myImage->xmlGetData();
		output += "\n";
		output += myIO->xmlGetData();
		output += "\n";

		EDomElement e(output);
		output = e.indent('\t').getContent();

		const char* buffer = output.c_str();
		pFile = fopen (path.c_str(), "wb");
		fwrite (buffer, 1, output.length(), pFile);
		fclose (pFile);
		return true;
	}
	return false;
!!!142456.cpp!!!	load(in path : string) : bool
	if (started)
	{
		FILE* pFile;
		long lSize;
		char* buffer;
		size_t result;

		pFile = fopen (path.c_str(), "rb");
		if (pFile==NULL) {fputs ("File error",stderr); exit (1);}

		fseek (pFile , 0 , SEEK_END);
		lSize = ftell (pFile);
		rewind (pFile);

		buffer = (char*) malloc (sizeof(char)*lSize);
		if (buffer == NULL) {fputs ("Memory error",stderr); exit (2);}

		result = fread (buffer,1,lSize,pFile);
		if ((unsigned int) result != (unsigned int) lSize) {fputs ("Reading error",stderr); exit (3);}


		string strxml(buffer);
		EDomElement xml(strxml);

		mySensor->xmlSetData(xml.elementByTagName("Sensor").getContent());
		myImage->xmlSetData(xml.elementByTagName("image").getContent());
		myIO->xmlSetData(xml.elementByTagName("imageIO").getContent());

		fclose (pFile);
		free (buffer);
	}
	return false;
!!!142584.cpp!!!	getImageFile() : string
	if (myImage->getFilepath() == ".")
		return myImage->getFilename();
	else
	{
		string result = "";
		result += myImage->getFilepath();
		result += "/";
		result += myImage->getFilename();
		return result;
	}
!!!142712.cpp!!!	getFrameRows() : int
	int rows = 0;
	if (mySensor->is("SensorWithKnowDimensions"))
	{
		SensorWithKnowDimensions* sensor = (SensorWithKnowDimensions*)mySensor;
		rows = sensor->getFrameRows();
	}
	return rows;
!!!142840.cpp!!!	getFrameColumns() : int
	int cols = 0;
	if (mySensor->is("SensorWithKnowDimensions"))
	{
		SensorWithKnowDimensions* sensor = (SensorWithKnowDimensions*)mySensor;
		cols = sensor->getFrameColumns();
	}
	return cols;
!!!142968.cpp!!!	acceptIO() : void
	EDomElement newXml(manager->xmlGetData());
        if (newXml.elementByTagAtt("imageIO", "image_key", Conversion::intToString(myImage->getId())).getContent() != "")
                newXml.replaceChildByTagAtt("imageIO", "image_key", Conversion::intToString(myImage->getId()), myIO->xmlGetData());
	else
		newXml.addChildAtTagName("interiorOrientation", myIO->xmlGetData());
	manager->xmlSetData(newXml.getContent());
	manager->setSavedState(false);
