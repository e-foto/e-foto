class SImage
!!!163704.cpp!!!	SImage()
	this->parent = NULL;
	this->nickname = "";
	this->filePath = "";
	this->tile.clear();
	this->tileSize = 32768;
	this->width = 0;
	this->height = 0;
	this->canLoaded = false;
	this->format = 0;
!!!163832.cpp!!!	SImage(inout parent : SWidget, in nickname : string, in filename : string)
	this->parent = parent;
	this->nickname = nickname;
	this->filePath = filename;
	this->tile.clear();
	// Ate o momento a imagem que não consegue fazer o load não entra na estrutura da SWidget e não é texturizada.
	if (this->load(filePath))
	{
		this->tileSize = 32768;
		canLoaded = this->createTextureTiles();
	}
!!!163960.cpp!!!	~SImage()
	this->removeViewportExhibitions();
	//this->removeMarks();
!!!164088.cpp!!!	getNickname() : string
	return nickname;
!!!164216.cpp!!!	getWidth() : int
	return width;
!!!164344.cpp!!!	getHeight() : int
	return height;
!!!164472.cpp!!!	loaded() : bool
	return canLoaded;
!!!164600.cpp!!!	getFormat() : int
	return this->format;
!!!164728.cpp!!!	isInsideImage(in x : double, in y : double, in viewportNickname : string) : bool
	sclass::SImageInViewport* exhibition;
	bool found = false;
	for (unsigned int i = 0; i < exposedInViewport.size(); i++)
	{
		if (exposedInViewport.at(i)->getViewportNickname() == viewportNickname)
		{
			exhibition = exposedInViewport.at(i);
			found = true;
		}
	}
	if (!found)
		return false;

	double newX = (x - exhibition->getX())/exhibition->getEfectiveZoom();
	double newY = (y - exhibition->getY())/exhibition->getEfectiveZoom();

	if (!(newX < -width/2 || newX > width/2 || newY > height/2 || newY < -height/2))
		return true;
	else
		return false;
!!!164856.cpp!!!	addExhibition(inout exhibition : SImageInViewport) : void
	if (exhibition->getImageNickname() == nickname)
	{
		string viewportNickname = exhibition->getViewportNickname();
		// Impedimos associação que aponte um viewport de nickname inválido.
		if (viewportNickname == "" || string::npos != viewportNickname.find(";") || isShowedInViewport(viewportNickname))
			return;
		exposedInViewport.push_back(exhibition);
	}
!!!164984.cpp!!!	removeExhibition(inout exhibition : SImageInViewport) : void
	for (unsigned int i = 0; i < exposedInViewport.size(); i++)
	{
		if (exposedInViewport.at(i) == exhibition)
		{
			exposedInViewport.erase(exposedInViewport.begin()+i);
			break;
		}
	}
!!!165112.cpp!!!	removeViewportExhibitions() : void
	while (!exposedInViewport.empty())
		delete exposedInViewport.at(0);
!!!165240.cpp!!!	isShowedInViewport(in viewportNickname : string) : bool
	for (unsigned int i = 0; i < exposedInViewport.size(); i++)
	{
		if (exposedInViewport.at(i)->getViewportNickname() == viewportNickname)
		{
			return true;
		}
	}
	return false;
!!!165368.cpp!!!	panInViewport(in dx : int, in dy : int, in viewportNickname : string) : void
	for (unsigned int i = 0; i < exposedInViewport.size(); i++)
	{
		if (exposedInViewport.at(i)->getViewportNickname() == viewportNickname)
		{
			exposedInViewport.at(i)->pan(dx, dy);
		}
	}
!!!165496.cpp!!!	addExhibition(inout exhibition : SMarkInImage) : void
	if (exhibition->getImageNickname() == nickname)
	{
		string markNickname = exhibition->getMarkNickname();
		// Impedimos associação que aponte uma image de nickname inválido.
		if (markNickname == "" || string::npos != markNickname.find(";") || containsMark(markNickname))
			return;
		exposeMark.push_back(exhibition);
	}
!!!165624.cpp!!!	removeExhibition(inout exhibition : SMarkInImage) : void
	for (unsigned int i = 0; i < exposeMark.size(); i++)
	{
		if (exposeMark.at(i) == exhibition)
		{
			exposeMark.erase(exposeMark.begin()+i);
			break;
		}
	}
!!!165752.cpp!!!	removeMarkExhibitions() : void
	while (!exposeMark.empty())
		delete exposeMark.at(0);
!!!165880.cpp!!!	containsMark(in markNickname : string) : bool
	for (unsigned int i = 0; i < exposeMark.size(); i++)
	{
		if (exposeMark.at(i)->getMarkNickname() == markNickname)
		{
			return true;
		}
	}
	return false;
!!!166008.cpp!!!	addMark(inout point : Point, in x : double, in y : double, inout viewport : Viewport = 0, in withImageCoord : bool = false) : void
	// Se a marca foi adicionada com clique num viewport descontaremos o deslocamento da imagem no mesmo.
	if (viewport != NULL && !withImageCoord)
	{
		for (unsigned int i = 0; i < exposedInViewport.size(); i++)
		{
			if (exposedInViewport.at(i)->getViewportNickname() == viewport->getNickname())
			{
				x -= exposedInViewport.at(i)->getX();
				x /= exposedInViewport.at(i)->getEfectiveZoom();
				y -= exposedInViewport.at(i)->getY();
				y /= exposedInViewport.at(i)->getEfectiveZoom();

			}
		}
	}
	else
	{
		x -= width/2;
		y *= -1;
		y += height/2;
	}

	// Realizamos uma busca para determinar se a marca j´a n~ao ´e vis´ivel sobre a imagem.
	bool found = false;
	for (unsigned int i = 0; i < exposeMark.size(); i++)
	{
		if (exposeMark.at(i)->getMarkNickname() == point->getNickname())
		{
			found = true;
			// Se a marca existe apenas movemos ela.
			exposeMark.at(i)->moveTo(x,y);
		}
	}

	// Se a marca n~ao existe ela deve ser criada.
	if (!found)
		new sclass::SMarkInImage(point,this,x,y);
!!!166136.cpp!!!	draw(inout link : SImageInViewport) : void
	if (link != NULL)
	{
		double zoom = link->getEfectiveZoom();
		double x = link->getX();
		double y = link->getY();
		for (unsigned int i = 0; i < tile.size(); i++)
		{
			tile.at(i).draw(x, y, zoom);
		}
		for (unsigned int i = 0; i < exposeMark.size(); i++)
		{
			exposeMark.at(i)->draw(x, y, zoom);
		}
	}
!!!166264.cpp!!!	unload() : void
	for (unsigned int i = 0; i < tile.size(); i++)
		tile.at(i).untexturize();
	tile.clear();
	canLoaded = false;
!!!166392.cpp!!!	reload(in filePath : string) : bool
	for (unsigned int i = 0; i < tile.size(); i++)
		tile.at(i).untexturize();
	tile.clear();
	this->filePath = filePath;
	if (this->load(filePath))
	{
		this->tileSize = 32768;
		canLoaded = this->createTextureTiles();
	}
	return canLoaded;
!!!166520.cpp!!!	load(in filePath : string) : bool
	return CommonMethods::instance()->loadImage(width,height,format,filePath);
!!!166648.cpp!!!	createTextureTiles() : bool
	int n = (int)(log((float)tileSize)/log(2.0));

	while (n >= 0 && (width < tileSize || height < tileSize || !checkSizeTile(tileSize)))
	{
		tileSize = pow(2,n);
		n--;
	}

	if (tileSize <= 1)
	{
		return false;
	}

	int gridCol = floor((double)width / tileSize);
	int gridRow = floor((double)height / tileSize);
	if (width == tileSize)
		gridCol = 0;
	if (height == tileSize)
		gridRow = 0;
	bool completSucess = true;

	for (int i = 0; i <= gridRow; i++)
	{
		for (int j = 0; j <= gridCol; j++)
		{
			int l,t,w,h;
			if (gridCol != 0)
				l = (width - tileSize) * j / gridCol;
			else
				l = 0;
			if (gridRow != 0)
				t = (height - tileSize) * i / gridRow;
			else
				t = 0;
			w = tileSize;
			h = tileSize;
			sclass::STile thisTile = STile(-width/2 + tileSize/2 + l, -1.0 * (-height/2 + tileSize/2 + t), this, l, t, w, h);
			if (thisTile.isTexturized())
			{
				tile.push_back(thisTile);
			}
			else
			{
				completSucess = false;
				unload();
				break;
			}
		}
		if (!completSucess)
			break;
	}

	// Como o OpenGL copiou a imagem em diversos tiles, apagamos a imagem gerada pelo CommonMethod.
	CommonMethods::instance()->freeImage();

	return completSucess;
