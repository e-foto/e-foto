class PositionMatrix
!!!200824.cpp!!!	del() : void

    delete[] _Mat;
    _Mat = NULL;
    ncols = 0;
    nrows = 0;
    unit = "";
!!!200952.cpp!!!	nw(in rows : uint, in cols : uint) : void

    _Mat = new double[rows * cols];               // Allocate matrix
    nrows = rows; ncols = cols;                   // Fill matrix' attributes.
    for(unsigned int i = 0; i < (rows * cols); i++) //set its elements to zero
        _Mat[i] = 0;
    unit = "";
!!!201080.cpp!!!	PositionMatrix(in dimensions : uint, in newUnit : string)

    nw(dimensions, 1); // Allocate matrix and fill its attributes.
    unit = newUnit;
!!!201208.cpp!!!	PositionMatrix(in anotherMatrix : Matrix)

    nw(anotherMatrix.getRows(), anotherMatrix.getCols());
    *this = anotherMatrix; // Allocate matrix and fill its attributes.
!!!201336.cpp!!!	PositionMatrix(in anotherMatrix : PositionMatrix)

    nw(anotherMatrix.getRows(), anotherMatrix.getCols());
    *this = anotherMatrix; // Allocate matrix and fill its attributes.
!!!201464.cpp!!!	PositionMatrix()

    _Mat = NULL;
!!!201592.cpp!!!	~PositionMatrix()

    del();
!!!201720.cpp!!!	resize(in rows : uint, in cols : uint = 1) : PositionMatrix

    PositionMatrix result;
    result.nw(rows, cols);
    for (unsigned int i = 1; (i <= result.nrows)&&(i <= nrows); i++)
        for (unsigned int j = 1; (j <= result.ncols)&&(j <= ncols); j++)
            result.set(i,j,get(i,j));
    *this = result;
    return *this;
!!!201848.cpp!!!	zero() : PositionMatrix

    for(unsigned int i = 0; i < (nrows * ncols); i++)
        _Mat[i] = 0;
    return *this;
!!!201976.cpp!!!	load(inout filename : char) : int
//@CODE_63
    char str[256];
    unsigned int cols;
    unsigned int rows;

    ifstream arq(filename); // open the emf file
    if (!arq.fail())
    {
        arq.getline(str,255); // read file header
        if (!arq.fail())
        {
            arq.getline(str,255); // read filename
            if (!arq.fail())
            {
                arq >> cols;
                if (!arq.fail())
                {
                    arq >> rows;
                    if ((nrows != rows)||(ncols != cols))
                    {
                        del();
                        nw(rows, cols);
                    }
                    for (unsigned int i=0; (!arq.eof())||(!arq.fail())||(i < (cols * rows)); i++)
                    {
                        arq >> _Mat[i]; // read one matrix element
                    }
                    arq.close();
                    return 1;
                }
            }

        }
    }
    return 0;
!!!202104.cpp!!!	save(inout filename : char) : int

    ofstream emfile(filename); // open the emf file
    if (!emfile.fail())
    {
        emfile << "E-foto project double PositionMatrix Format" << endl; // write file header
        if (!emfile.fail())
        {
            emfile << filename << endl; // write filename
            if (!emfile.fail())
            {
                emfile << ncols << " " << nrows << endl;
                if (!emfile.fail())
                {
                    for (unsigned int i = 0; (i < (ncols * nrows)); i++)
                    {
                        emfile << _Mat[i] << " "; // write one matrix element
                    }
                    emfile.close();
                    return 1;
                }

            }
        }
    }
    return 0;
!!!202232.cpp!!!	get(in i : uint, in j : uint = 1) : double

    if ((i >= 1)&&(i <= nrows)&&(j >= 1)&&(j <= ncols))
        return _Mat[(i-1) * ncols + j - 1];
    else
        cerr << "i, j values out of the range of the matrix." << endl;
    return 0;
!!!202360.cpp!!!	getInt(in i : uint, in j : uint = 1) : int

    return (int) get(i,j);
!!!202488.cpp!!!	getUnit() : string

    return unit;
!!!202616.cpp!!!	sel(in FirstRow : uint, in LastRow : uint, in FirstCol : uint = 1, in LastCol : uint = 1) : PositionMatrix

    PositionMatrix DraftResult;
    PositionMatrix Result;
    if((FirstRow > LastRow)||(FirstCol > LastCol)||(FirstRow < 1)||(FirstCol < 1)||(LastRow > nrows)||(LastCol > ncols))
    {
        cerr << "Error detected by the Matrix.sel() method:" << endl << "Input parameters out of range or incorrect."<<endl;
        return Result;
    }
    if ( (DraftResult.nrows != (LastRow-FirstRow+1)) || (DraftResult.ncols != (LastCol-FirstCol+1)) )
    {
        DraftResult.del();
        DraftResult.nw( (unsigned int)(LastRow-FirstRow+1), (unsigned int) (LastCol-FirstCol+1) );
    }
    for (unsigned int i = 1; i <= (LastRow-FirstRow+1); i++)
        for (unsigned int j = 1; j <= (LastCol-FirstCol+1); j++)
            DraftResult.set(i, j, get((FirstRow + i - 1),(FirstCol + j -1)));

    Result = DraftResult;
    Result.unit = unit;
    return Result;
!!!202744.cpp!!!	show() : void

    cout << "PositionMatrix " << nrows << 'x' << ncols << " (" << unit << ")" << endl;
    cout.setf(ios::fixed | ios::scientific);
    for (unsigned int i = 1; i <= nrows; i++)
    {
        for (unsigned int j = 1; j <= ncols; j++)
            //printf("%10.1f ", get((unsigned int) i, (unsigned int) j));
            cout << setw(9) << setprecision(3) <<  get((unsigned int) i, (unsigned int) j) << " ";
        cout << endl;
    }
    cout.unsetf(ios::fixed | ios::scientific);
    cout << endl;
!!!202872.cpp!!!	set(in i : uint, in j : uint, in value : double) : void

    if ((i >= 1)&&(i <= nrows)&&(j >= 1)&&(j <= ncols))
        _Mat[(i-1) * ncols + j - 1]=value;
    else
        cerr << "i, j values out of the range of the matrix." << endl;
!!!203000.cpp!!!	set(in i : uint, in value : double) : void

    set(i,1, value);
!!!203128.cpp!!!	setInt(in i : uint, in j : uint, in value : int) : void

    set(i,j, (double) value);
!!!203256.cpp!!!	setInt(in i : uint, in value : int) : void

    set(i,1, (double) value);
!!!203384.cpp!!!	setUnit(in newUnit : string) : void

    unit = newUnit;
!!!203512.cpp!!!	operator &(in Par_Matrix : PositionMatrix) : PositionMatrix
//@CODE_141
    PositionMatrix DraftResult;
    PositionMatrix Result;
    if (Par_Matrix.nrows!=nrows)
    {
        cerr << "Error detected by the & operator:" << endl<< "Both matrixes must have the same number of rows." << endl;
    }
    else
    {
        if ((DraftResult.nrows*DraftResult.ncols)==(nrows*(ncols+Par_Matrix.ncols))) // If total size of the resulting matrix is correct
        {
            DraftResult.nrows=nrows;                                // Just update the dimensions
            DraftResult.ncols=ncols+Par_Matrix.ncols;
        }
        else
        {
            DraftResult.del();
            DraftResult.nw(nrows, ncols+Par_Matrix.ncols);
        }
        for (unsigned int i=1; i<=(nrows); i++)
        {
            for (unsigned int j=1; j<=(ncols); j++)
                DraftResult.set((unsigned int)i,(unsigned int)j,get((unsigned int)i,(unsigned int)j));
            for (unsigned int j=1; j<=(Par_Matrix.ncols); j++)
                DraftResult.set((unsigned int)i,(unsigned int)(j+ncols),Par_Matrix.get((unsigned int)i,(unsigned int)j));
        }
        Result = DraftResult;
        Result.unit = unit;
        return Result;
    }
    return Result;
!!!203640.cpp!!!	operator |(in Par_Matrix : PositionMatrix) : PositionMatrix
//@CODE_141
    PositionMatrix Result;

    if (Par_Matrix.ncols!=ncols)
    {
        cerr << "Error detected by the | operator:" << endl<< "Both matrixes must have the same number of cols." << endl;
    }
    else
    {
        PositionMatrix DraftResult;
        DraftResult.resize(nrows+Par_Matrix.nrows, ncols);

        for (unsigned int j=1; j<=(ncols); j++)
        {
            for (unsigned int i=1; i<=(nrows); i++)
                DraftResult.set((unsigned int)i,(unsigned int)j,get((unsigned int)i,(unsigned int)j));
            for (unsigned int i=1; i<=(Par_Matrix.nrows); i++)
                DraftResult.set((unsigned int)(i+nrows),(unsigned int)j,Par_Matrix.get((unsigned int)i,(unsigned int)j));
        }
        Result = DraftResult;
        Result.unit = unit;
    }

    return Result;
!!!203768.cpp!!!	operator =(in Par_Matrix : Matrix) : PositionMatrix

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
    {
        del();
        nw(Par_Matrix.nrows,Par_Matrix.ncols);
    }
    for (unsigned int i = 0; i < (nrows*ncols); i++)
    {
        _Mat[i]=Par_Matrix._Mat[i];
    }
    unit = Par_Matrix.unit;
    return *this;
!!!203896.cpp!!!	operator =(in Par_Matrix : PositionMatrix) : PositionMatrix

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
    {
        del();
        nw(Par_Matrix.nrows,Par_Matrix.ncols);
    }
    for (unsigned int i = 0; i < (nrows*ncols); i++)
    {
        _Mat[i]=Par_Matrix._Mat[i];
    }
    unit = Par_Matrix.unit;
    return *this;
!!!204024.cpp!!!	operator ==(in Par_Matrix : Matrix) : bool

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 0;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 0;
    return 1;
!!!204152.cpp!!!	operator ==(in Par_Matrix : PositionMatrix) : bool

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 0;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 0;
    return 1;
!!!204280.cpp!!!	operator !=(in Par_Matrix : Matrix) : bool

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 1;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 1;
    return 0;
!!!204408.cpp!!!	operator !=(in Par_Matrix : PositionMatrix) : bool

    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 1;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 1;
    return 0;
!!!204536.cpp!!!	objectType(in  : void) : string

    return "PositionMatrix";
!!!204664.cpp!!!	objectAssociations(in  : void) : string

    return "";
!!!204792.cpp!!!	is(in s : string) : bool

    return (s == "PositionMatrix" ? true : false);
!!!204920.cpp!!!	xmlGetData() : string

    stringstream result;
    result << "<gml:pos>" << this->toGmlPosFormat() << "</gml:pos>\n";
    return result.str();
!!!205048.cpp!!!	xmlSetData(in xml : string) : void

    EDomElement root(xml);
    deque<double> values = root.toGmlPos();
    resize(values.size());
    for (unsigned int i = 0; i < values.size(); i++)
        set(i, values.at(i));
!!!205176.cpp!!!	toDiagonal() : PositionMatrix

    PositionMatrix Result;
    if ((ncols == 1)||(nrows == 1))
    {
        Result.resize(ncols*nrows, ncols*nrows);
        for (unsigned int i = 1; i <= nrows; i++)
            for(unsigned int j = 1; j <= ncols; j++)
                Result.set(i*j, i*j, get(i,j));
    }
    //Aqui pode ser incluido um else que revele um erro nessa operação que pede um vetor como entrada.
    Result.unit = unit;
    return Result;
!!!205304.cpp!!!	toGmlPosFormat() : string

    stringstream oss;
    for (unsigned int i = 1; i <= nrows; i++)
        for (unsigned int j = 1; j <= ncols; j++)
        {
        oss << Conversion::doubleToString(get((unsigned int) i, (unsigned int) j));
        if ( !( ( i == nrows) && (j == ncols) ) )
            oss << " ";
    };
    return oss.str();
