class IOQuality
!!!235384.cpp!!!	getV() : Matrix
	return V;
!!!235512.cpp!!!	getsigma0Squared() : double
	return sigma0Squared;
!!!235640.cpp!!!	getSigmaXa() : Matrix
	return SigmaXa;
!!!235768.cpp!!!	getSigmaLa() : Matrix
	return SigmaLa;
!!!235896.cpp!!!	objectType(in  : void) : string
	return "IOQuality";
!!!236024.cpp!!!	objectAssociations(in  : void) : string
	return "";
!!!236152.cpp!!!	is(in s : string) : bool
	return (s == "IOQuality" ? true : false);
!!!236280.cpp!!!	xmlSetData(in xml : string) : void
	EDomElement root(xml);
	V.xmlSetData(root.elementByTagName("V").elementByTagName("mml:matrix").getContent());
	if (root.elementByTagName("sigma0Squared").isAvailable())
		sigma0Squared = root.elementByTagName("sigma0Squared").toDouble();
	else
		sigma0Squared = 1.0;
	if (root.elementByTagName("SigmaXa").isAvailable())
		SigmaXa.xmlSetData(root.elementByTagName("SigmaXa").elementByTagName("mml:matrix").getContent());
	else
		SigmaXa.identity(6);
	if (root.elementByTagName("SigmaLa").isAvailable())
		SigmaLa.xmlSetData(root.elementByTagName("SigmaLa").elementByTagName("mml:matrix").getContent());
	else
		SigmaLa.identity(1);
!!!236408.cpp!!!	xmlGetData() : string
	stringstream result;
	result << "<quality>\n";
	result << "<V>\n";
	result << V.xmlGetData();
	result << "</V>\n";
	if (sigma0Squared == 1.0)
		result << "<sigma0Squared>Not Available</sigma0Squared>\n";
	else
                result << "<sigma0Squared>" << Conversion::doubleToString(sigma0Squared) << "</sigma0Squared>\n";
	if (SigmaXa.isIdentity())
		result << "<SigmaXa>Not Available</SigmaXa>\n";
	else
	{
		result << "<SigmaXa>\n";
		result << SigmaXa.xmlGetData();
		result << "</SigmaXa>\n";
	}
	if (SigmaLa.isIdentity())
		result << "<SigmaLa>Not Available</SigmaLa>\n";
	else
	{
		result << "<SigmaLa>\n";
		result << SigmaLa.xmlGetData();
		result << "</SigmaLa>\n";
	}
	result << "</quality>\n";
	return result.str();
!!!236536.cpp!!!	calculate(inout myIO : InteriorOrientation, inout mySensor : Sensor) : void
	if (mySensor->is("SensorWithFiducialMarks"))
	{
		SensorWithFiducialMarks* mySensorWithFiducialMarks = (SensorWithFiducialMarks*) mySensor;
		V = (myIO->getA() * myIO->getXa()) - mySensorWithFiducialMarks->getLb();
		sigma0Squared = (((V.transpose() * myIO->getP()) * V) / (mySensorWithFiducialMarks->getLb().getRows() - myIO->getXa().getRows())).get(1,1);
		SigmaXa = ((myIO->getA().transpose() * myIO->getP()) * myIO->getA()).inverse() * sigma0Squared;
		SigmaLa = ((myIO->getA() * ((myIO->getA().transpose() * myIO->getP()) * myIO->getA()).inverse()) * myIO->getA().transpose()) * sigma0Squared;
	}
	else if (mySensor->is("SensorWithKnowDimensions"))
	{
		SensorWithKnowDimensions* mySensorWithKnowDimensions = (SensorWithKnowDimensions*) mySensor;
		V = (myIO->getA() * myIO->getXa()) - mySensorWithKnowDimensions->forgeLb();
		sigma0Squared = (((V.transpose() * myIO->getP()) * V) / (mySensorWithKnowDimensions->forgeLb().getRows() - myIO->getXa().getRows())).get(1,1);
		SigmaXa = ((myIO->getA().transpose() * myIO->getP()) * myIO->getA()).inverse() * sigma0Squared;
		SigmaLa = ((myIO->getA() * ((myIO->getA().transpose() * myIO->getP()) * myIO->getA()).inverse()) * myIO->getA().transpose()) * sigma0Squared;
	}
