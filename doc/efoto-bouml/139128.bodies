class Matrix
!!!194168.cpp!!!	del() : void
    delete[] _Mat;
    _Mat = NULL;
    ncols = 0;
    nrows = 0;
    unit = "";
!!!194296.cpp!!!	nw(in rows : uint, in cols : uint) : void
    Matrix::_Mat = new double[rows * cols];       // Allocate matrix
    nrows = rows; ncols = cols;                   // Fill matrix' attributes.
    for(unsigned int i = 0; i < (rows * cols); i++) //set its elements to zero
        _Mat[i] = 0;
    unit = "";
!!!194424.cpp!!!	Matrix(in rows : uint, in cols : uint)
    nw(rows, cols); // Allocate matrix and fill its attributes.
!!!194552.cpp!!!	Matrix(in anotherMatrix : PositionMatrix)
    nw(anotherMatrix.getRows(), anotherMatrix.getCols());
    *this = anotherMatrix; // Allocate matrix and fill its attributes.
!!!194680.cpp!!!	Matrix(in anotherMatrix : Matrix)
    nw(anotherMatrix.getRows(), anotherMatrix.getCols());
    *this = anotherMatrix; // Allocate matrix and fill its attributes.
!!!194808.cpp!!!	Matrix()
    _Mat = NULL;
    unit = "";
!!!194936.cpp!!!	~Matrix()
    del();
!!!195064.cpp!!!	resize(in rows : uint, in cols : uint) : Matrix
    Matrix result;
    result.nw(rows, cols);
    for (unsigned int i = 1; (i <= result.nrows)&&(i <= nrows); i++)
        for (unsigned int j = 1; (j <= result.ncols)&&(j <= ncols); j++)
            result.set(i,j,get(i,j));
    *this = result;
    return *this;
!!!195192.cpp!!!	identity(in size : uint) : Matrix
    if ((size != ncols)||(size != nrows))
    {
        del();
        nw(size, size);
    }
    for(unsigned int i = 0; i < (size * size); i++) // creates an zeros matrix
        _Mat[i] = 0;
    for(unsigned int i = 1; i <= (size); i++)       // assigns ones to the main diagolnal elements.
        set((unsigned int) i, (unsigned int) i, 1);
    return *this;
!!!195320.cpp!!!	ones() : Matrix
    for(unsigned int i = 0; i < (nrows * ncols); i++)
        _Mat[i] = 1;
    return *this;
!!!195448.cpp!!!	zero() : Matrix
    for(unsigned int i = 0; i < (nrows * ncols); i++)
        _Mat[i] = 0;
    return *this;
!!!195576.cpp!!!	load(inout filename : char) : int
//@CODE_63
    char str[256];
    unsigned int cols;
    unsigned int rows;

    ifstream arq(filename); // open the emf file
    if (!arq.fail())
    {
        arq.getline(str,255); // read file header
        if (!arq.fail())
        {
            arq.getline(str,255); // read filename
            if (!arq.fail())
            {
                arq >> cols;
                if (!arq.fail())
                {
                    arq >> rows;
                    if ((nrows != rows)||(ncols != cols))
                    {
                        del();
                        nw(rows, cols);
                    }
                    for (unsigned int i=0; (!arq.eof())||(!arq.fail())||(i < (cols * rows)); i++)
                    {
                        arq >> _Mat[i]; // read one matrix element
                    }
                    arq.close();
                    return 1;
                }
            }

        }
    }
    return 0;
!!!195704.cpp!!!	save(inout filename : char) : int
    ofstream emfile(filename); // open the emf file
    if (!emfile.fail())
    {
        emfile << "E-foto project double Matrix Format" << endl; // write file header
        if (!emfile.fail())
        {
            emfile << filename << endl; // write filename
            if (!emfile.fail())
            {
                emfile << ncols << " " << nrows << endl;
                if (!emfile.fail())
                {
                    for (unsigned int i = 0; (i < (ncols * nrows)); i++)
                    {
                        emfile << _Mat[i] << " "; // write one matrix element
                    }
                    emfile.close();
                    return 1;
                }

            }
        }
    }
    return 0;
!!!195832.cpp!!!	get(in i : uint, in j : uint) : double
    if ((i >= 1)&&(i <= nrows)&&(j >= 1)&&(j <= ncols))
        return _Mat[(i-1) * ncols + j - 1];
    else
        cerr << "i, j values out of the range of the matrix." << endl;
    return 0;
!!!195960.cpp!!!	getInt(in i : uint, in j : uint) : int
    return (int) get(i,j);
!!!196088.cpp!!!	getUnit() : string
    return unit;
!!!196216.cpp!!!	sel(in FirstRow : uint, in LastRow : uint, in FirstCol : uint, in LastCol : uint) : Matrix
    Matrix DraftResult(1, 1);
    Matrix Result;
    if((FirstRow > LastRow)||(FirstCol > LastCol)||(FirstRow < 1)||(FirstCol < 1)||(LastRow > nrows)||(LastCol > ncols))
    {
        cerr << "Error detected by the Matrix.sel() method:" << endl << "Input parameters out of range or incorrect."<<endl;
        return Result;
    }
    if ( (DraftResult.nrows != (LastRow-FirstRow+1)) || (DraftResult.ncols != (LastCol-FirstCol+1)) )
    {
        DraftResult.del();
        DraftResult.nw( (unsigned int)(LastRow-FirstRow+1), (unsigned int) (LastCol-FirstCol+1) );
    }
    for (unsigned int i = 1; i <= (LastRow-FirstRow+1); i++)
        for (unsigned int j = 1; j <= (LastCol-FirstCol+1); j++)
            DraftResult.set(i, j, get((FirstRow + i - 1),(FirstCol + j -1)));

    Result = DraftResult;
    Result.unit = unit;
    return Result;
!!!196344.cpp!!!	show() : void
    cout << "Matrix " << nrows << 'x' << ncols << endl;
    cout.setf(ios::fixed | ios::scientific);
    for (unsigned int i = 1; i <= nrows; i++)
    {
        for (unsigned int j = 1; j <= ncols; j++)
            //printf("%10.1f ", get((unsigned int) i, (unsigned int) j));
            cout << setw(15) << setprecision(8) <<  get((unsigned int) i, (unsigned int) j) << " ";
        cout << endl;
    }
    cout.unsetf(ios::fixed | ios::scientific);
    cout << endl;
!!!196472.cpp!!!	highestValue() : double
    double Result = NAN;
    if (_Mat != NULL)
    {
        Result = _Mat[0];
        for (unsigned int i = 1; i < (ncols*nrows); i++)
            if (_Mat[i] > Result)
                Result = _Mat[i];
    }
    return Result;
!!!196600.cpp!!!	lowestValue() : double
    double Result = NAN;
    if (_Mat != NULL)
    {
        Result = _Mat[0];
        for (unsigned int i = 1; i < (ncols*nrows); i++)
            if (_Mat[i] < Result)
                Result = _Mat[i];
    }
    return Result;
!!!196728.cpp!!!	set(in i : uint, in j : uint, in value : double) : void
    if ((i >= 1)&&(i <= nrows)&&(j >= 1)&&(j <= ncols))
        _Mat[(i-1) * ncols + j - 1]=value;
    else
        cerr << "i, j values out of the range of the matrix." << endl;
!!!196856.cpp!!!	setInt(in i : uint, in j : uint, in value : int) : void
    set(i,j, (double) value);
!!!196984.cpp!!!	setUnit(in newUnit : string) : void
    unit = newUnit;
!!!197112.cpp!!!	isIdentity() : bool
    Matrix I;
    if (getCols() != getRows())
        return false;
    I.identity(getCols());
    if (*this != I)
        return false;
    return true;
!!!197240.cpp!!!	isTriang() : bool
	for (unsigned int j = 1; j <= ncols; j++)
	{
		if ((1-get((unsigned int)j,(unsigned int)j) > 0.000001 || 1-get((unsigned int)j,(unsigned int)j) < -0.000001))
			return false;
		for (unsigned int i = (j+1); i <= nrows; i++)
			if (get((unsigned int)i,(unsigned int)j) > 0.000001 || get((unsigned int)i,(unsigned int)j) < -0.000001)
				return false;
	}
	return true;
!!!197368.cpp!!!	isZeroes() : bool
	for (unsigned int j = 1; j <= ncols; j++)
	{
		for (unsigned int i = 1; i <= nrows; i++)
			if (get((unsigned int)i,(unsigned int)j) > 0.000001 || get((unsigned int)i,(unsigned int)j) < -0.000001)
				return false;
	}
	return true;
!!!197496.cpp!!!	operator &(in Par_Matrix : Matrix) : Matrix
//@CODE_141
    Matrix DraftResult;
    Matrix Result;
    if (Par_Matrix.nrows!=nrows)
    {
        cerr << "Error detected by the & operator:" << endl<< "Both matrixes must have the same number of rows." << endl;
    }
    else
    {
        if ((DraftResult.nrows*DraftResult.ncols)==(nrows*(ncols+Par_Matrix.ncols))) // If total size of the resulting matrix is correct
        {
            DraftResult.nrows=nrows;                                // Just update the dimensions
            DraftResult.ncols=ncols+Par_Matrix.ncols;
        }
        else
        {
            DraftResult.del();
            DraftResult.nw(nrows, ncols+Par_Matrix.ncols);
        }
        for (unsigned int i=1; i<=(nrows); i++)
        {
            for (unsigned int j=1; j<=(ncols); j++)
                DraftResult.set((unsigned int)i,(unsigned int)j,get((unsigned int)i,(unsigned int)j));
            for (unsigned int j=1; j<=(Par_Matrix.ncols); j++)
                DraftResult.set((unsigned int)i,(unsigned int)(j+ncols),Par_Matrix.get((unsigned int)i,(unsigned int)j));
        }
        Result = DraftResult;
        Result.unit = unit;
        return Result;
    }
    return Result;
!!!197624.cpp!!!	operator |(in Par_Matrix : Matrix) : Matrix
//@CODE_141
    Matrix Result;

    if (Par_Matrix.ncols!=ncols)
    {
        cerr << "Error detected by the | operator:" << endl<< "Both matrixes must have the same number of cols." << endl;
    }
    else
    {
        Matrix DraftResult(nrows+Par_Matrix.nrows, ncols);

        for (unsigned int j=1; j<=(ncols); j++)
        {
            for (unsigned int i=1; i<=(nrows); i++)
                DraftResult.set((unsigned int)i,(unsigned int)j,get((unsigned int)i,(unsigned int)j));
            for (unsigned int i=1; i<=(Par_Matrix.nrows); i++)
                DraftResult.set((unsigned int)(i+nrows),(unsigned int)j,Par_Matrix.get((unsigned int)i,(unsigned int)j));
        }
        Result = DraftResult;
        Result.unit = unit;
    }

    return Result;
!!!197752.cpp!!!	operator +(in Par_Matrix : Matrix) : Matrix
    Matrix DraftResult(Par_Matrix.nrows, Par_Matrix.ncols);
    Matrix Result;
    if ((Par_Matrix.nrows!=nrows)||(Par_Matrix.ncols!=ncols) )
    {
        cerr << "Error detected by the + operator: Both matrixes must have the same dimensions." << endl;
    }
    else
    {
        if ((DraftResult.nrows*DraftResult.ncols)==(nrows*ncols))
        {
            DraftResult.nrows=nrows;
            DraftResult.ncols=ncols;
        }
        else
        {
            DraftResult.nw(nrows, ncols);
        }
        for (unsigned int i=0; i<(nrows*ncols); i++)
        {
            DraftResult._Mat[i]=_Mat[i] + Par_Matrix._Mat[i];
        }
        Result = DraftResult;
        Result.unit = unit;
        return Result;
    }
    return Result;
!!!197880.cpp!!!	operator -(in Par_Matrix : Matrix) : Matrix
    Matrix DraftResult(Par_Matrix.nrows, Par_Matrix.ncols);
    Matrix Result;
    if ((Par_Matrix.nrows!=nrows)||(Par_Matrix.ncols!=ncols))
    {
        cerr << "Error detected by the - operator: Both matrixes must have the same dimensions." << endl;
    }
    else
    {
        if ((DraftResult.nrows*DraftResult.ncols)==(nrows*ncols) )
        {
            DraftResult.nrows=nrows;
            DraftResult.ncols=ncols;
        }
        else
        {
            DraftResult.nw(nrows, ncols);
        }
        for (unsigned int i=0; i<(nrows*ncols); i++)
        {
            DraftResult._Mat[i]=_Mat[i] - Par_Matrix._Mat[i];
        }
        Result = DraftResult;
        Result.unit = unit;
        return Result;
    }
    return Result;
!!!198008.cpp!!!	operator *(in Par_Matrix : Matrix) : Matrix
    Matrix Result;
    Matrix *DraftResult = new Matrix;
    DraftResult->resize(nrows, Par_Matrix.ncols).zero();

    if (ncols!=Par_Matrix.nrows)
    {
        cerr << "Matrices dimensions are imcompatible." << endl;
		//system("PAUSE");
        exit (-1);
    }
    else
    {
        //Allocates matrix
        for (unsigned int i = 1; i <=DraftResult->nrows; i++)
        {
            for (unsigned int j= 1;j<=DraftResult->ncols; j++)
            {
                double sum=0;
                for (unsigned int k=1; k <= ncols; k++)
                {
                    sum+=(get(i,k)*Par_Matrix.get(k,j));
                } // calculates one element of the result
                DraftResult->set(i,j,sum);
            }
        }

        Result = *DraftResult;
        Result.unit = unit;
        delete DraftResult;
        return Result;
    }
!!!198136.cpp!!!	operator +(in Par_Scalar : double) : Matrix
    Matrix DraftResult(nrows, ncols);
    Matrix Result(nrows, ncols);
    for (unsigned int i = 1; i <= Result.nrows; i++)
    {
        for (unsigned int j= 1;j<=Result.ncols; j++)
        {
            DraftResult.set(i,j,this->get(i,j)+Par_Scalar);
        }
    }
    Result = DraftResult;
    Result.unit = unit;
    return Result;
!!!198264.cpp!!!	operator -(in Par_Scalar : double) : Matrix
    Matrix DraftResult(nrows, ncols);
    Matrix Result(nrows, ncols);
    for (unsigned int i = 1; i <= Result.nrows; i++)
    {
        for (unsigned int j= 1;j<= Result.ncols; j++)
        {
            DraftResult.set(i,j,(this->get(i,j)-Par_Scalar));
        }
    }
    Result = DraftResult;
    Result.unit = unit;
    return Result;
!!!198392.cpp!!!	operator *(in Par_Scalar : double) : Matrix
    Matrix DraftMatrix (nrows, ncols);
    Matrix Result(nrows, ncols);
    for (unsigned int i = 1; i <= DraftMatrix.nrows; i++)
    {
        for (unsigned int j= 1;j<= DraftMatrix.ncols; j++)
        {
            DraftMatrix.set(i,j,this->get(i,j)*Par_Scalar);
        }
    }
    Result = DraftMatrix;
    Result.unit = unit;
    return Result;
!!!198520.cpp!!!	operator /(in Par_Scalar : double) : Matrix
    Matrix DraftResult(nrows, ncols);
    Matrix Result(nrows, ncols);
    for (unsigned int i = 1; i <= Result.nrows; i++)
    {
        for (unsigned int j= 1;j<= Result.ncols; j++)
        {
            DraftResult.set(i,j,this->get(i,j)/Par_Scalar);
        }
    }
    Result = DraftResult;
    Result.unit = unit;
    return Result;
!!!198648.cpp!!!	operator =(in Par_Matrix : PositionMatrix) : Matrix
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
    {
        del();
        nw(Par_Matrix.nrows,Par_Matrix.ncols);
    }
    for (unsigned int i = 0; i < (nrows*ncols); i++)
    {
        _Mat[i]=Par_Matrix._Mat[i];
    }
    unit = Par_Matrix.unit;
    return *this;
!!!198776.cpp!!!	operator =(in Par_Matrix : Matrix) : Matrix
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
    {
        del();
        nw(Par_Matrix.nrows,Par_Matrix.ncols);
    }
    for (unsigned int i = 0; i < (nrows*ncols); i++)
    {
        _Mat[i]=Par_Matrix._Mat[i];
    }
    unit = Par_Matrix.unit;
    return *this;
!!!198904.cpp!!!	operator ==(in Par_Matrix : PositionMatrix) : bool
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 0;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 0;
    return 1;
!!!199032.cpp!!!	operator ==(in Par_Matrix : Matrix) : bool
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 0;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 0;
    return 1;
!!!199160.cpp!!!	operator !=(in Par_Matrix : PositionMatrix) : bool
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 1;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 1;
    return 0;
!!!199288.cpp!!!	operator !=(in Par_Matrix : Matrix) : bool
    if ((nrows!=Par_Matrix.nrows)||(ncols!=Par_Matrix.ncols))
        return 1;
    else
        for (unsigned int i = 0; i < (ncols*nrows); i++)
            if (_Mat[i] - Par_Matrix._Mat[i] > 0.00000001 || _Mat[i] - Par_Matrix._Mat[i] < -0.00000001)
                return 1;
    return 0;
!!!199416.cpp!!!	objectType(in  : void) : string
    return "Matrix";
!!!199544.cpp!!!	objectAssociations(in  : void) : string
    return "";
!!!199672.cpp!!!	is(in s : string) : bool
    return (s == "Matrix" ? true : false);
!!!199800.cpp!!!	xmlGetData() : string
    stringstream result;
    result << "<mml:matrix>\n";
    for (unsigned int i = 1; i <= getRows(); i++)
    {
        result << "<mml:matrixrow>\n";
        for (unsigned int j = 1; j <= getCols(); j++)
            result << "<mml:cn>" << Conversion::doubleToString(get(i, j)) << "</mml:cn>\n";
        result << "</mml:matrixrow>\n";
    }
    result << "</mml:matrix>\n";
    return result.str();
!!!199928.cpp!!!	xmlSetData(in xml : string) : void
    EDomElement root(xml);

    deque<EDomElement> matRows, matCols;

    matRows = root.children();
    if (matRows.size() == 0)
        return;
    matCols = matRows.at(0).children();

    resize(matRows.size(), matCols.size());

    for (unsigned int i = 0; i < matRows.size(); i++)
    {
        matCols = matRows.at(i).children();
        for (unsigned int j = 0; j < matCols.size(); j++)
            set(i + 1, j + 1, matCols.at(j).toDouble());
    }
!!!200056.cpp!!!	inverse() : Matrix
    Matrix Inv;
    if (nrows != ncols)
        cerr << "Error detected by the inversion algorithm." << endl << "Matrix must  be square."<< endl;
    else
    {
        //Inversion method: standard Gauss-Jordan Elimination algorithm
        //When debuging this member function, you can uncomment the following lines.
        Matrix A_I;
        Matrix I;
        I.identity(ncols);

        A_I = *this;
        A_I = A_I & I;
        A_I = A_I.triang();
        A_I = A_I.reduction();
        A_I = A_I.sel(1,nrows,(ncols+1),(2*ncols));
        Inv = A_I;
    }
    return Inv;
!!!200184.cpp!!!	transpose() : Matrix
    Matrix Result;
    Result.resize(ncols, nrows).zero();
    for (unsigned int i = 1; i <= nrows; i++)
        for (unsigned int j = 1; j <= ncols; j++)
            Result.set(j, i, this->get(i,j));
    Result.unit = unit;
    return Result;
!!!200312.cpp!!!	reduction() : Matrix

    Matrix Result;
    Matrix LastResult;
    Result = *this;
    // this if the first value is too small it will performed a pivoting
    // @bug Bug may exist here!
    if (sqrt(pow(Result.get(1,1),2))<0.0000000001)
    {
        double MaximumValueinFirstColumn=0; // maximum absolute value in first columns
        unsigned int Maximum_Row=0;
        for(unsigned int i=1;i<=nrows;i++)
        {
            if (sqrt(pow(Result.get(i,1),2))>MaximumValueinFirstColumn)
            {
                Maximum_Row=i;
                MaximumValueinFirstColumn=Result.get(i,1);
            }
        }
        for (unsigned int j=1;j<=ncols;j++) //permutes the rows
        {
            Result.set(1,j,this->get(Maximum_Row,j));
            Result.set(Maximum_Row,j,this->get(1,j));
        }
    }
    // end of pivoting
    for (unsigned int i=nrows;i>=1;i--) // for each row
    {
        LastResult = Result;
        for(unsigned int j=ncols; j>=1;j--)
        {
            Result.set(i,j,(Result.get(i,j)/LastResult.get(i,i))); // divides all elements of row i per the element i, i of LastInteraction
            for(unsigned int i2=i-1; i2>=1; i2--)
                Result.set(i2,j,( Result.get(i2,j) - Result.get(i,j)*LastResult.get(i2,i)) ); // makes the elements in the column j of the next rows of the matrix equal to zero using linear combination of line
        }
    }
    return Result;
!!!200440.cpp!!!	triang() : Matrix
    // @bug A bug may exist here
    Matrix Result;
    Matrix LastResult;
    Result = *this;
    for (unsigned int i=1;i<=nrows;i++) // for each row
    {
        LastResult= Result;
        for(unsigned int j=i; j<=ncols;j++)
        {
            Result.set(i,j,(Result.get(i,j)/LastResult.get(i,i))); // divides all elements of row i per the element i, i of LastInteraction
            for(unsigned int i2=i+1; i2<=nrows; i2++)
                Result.set(i2,j, (Result.get(i2,j)-Result.get(i,j)*LastResult.get(i2,i)) ); // makes the elements in the column j of the next rows of the matrix equal to zero using linear combination of line
        }
    }
    return Result;
!!!200568.cpp!!!	toDiagonal() : Matrix
    Matrix Result;
    if ((ncols == 1)||(nrows == 1))
    {
        Result.resize(ncols*nrows, ncols*nrows);
        for (unsigned int i = 1; i <= nrows; i++)
            for(unsigned int j = 1; j <= ncols; j++)
                Result.set(i*j, i*j, get(i,j));
    }
    //Aqui pode ser incluido um else que revele um erro nessa operação que pede um vetor como entrada.
    Result.unit = unit;
    return Result;
!!!200696.cpp!!!	selDiagonal() : Matrix
    Matrix Result(*this);
    for (unsigned int i = 1; (i <= nrows) && (i <= ncols); i++)
    {
        Result.set(i,1,get(i,i));
    }
    Result.resize(nrows,1);
    return Result;
